;Exceptionally large Transit Timing Variations
;induced by two resonant warm gas giants in a three planet system.
;Michaela Vitkova et al
;https://arxiv.org/abs/2412.05609

[Astronomical Constants]     # Do not edit this section!
                             # You may use the astronomical constants defined in this section in
                             # all following sections, e.g. scope_left = 1.9 * au
g  = 6.67430e-11             # [m**3/kg/s**2] <float> gravitational constant +/- 0.00015
au = 1.495978707e11          # [m]   <float> astronomical unit
r_sun = 6.96342e8            # [m]   <float> solar radius
m_sun = 1.98847e30           # [kg]  <float> solar mass +/- 0.00007
l_sun = 3.83e26              # [W]   <float> solar luminosity
r_jup = 7.1492e7             # [m]   <float> Jupiter radius
m_jup = 1.8981246e27         # [kg]  <float> Jupiter mass
r_earth = 6.378135e6         # [m]   <float> Earth radius R⊕
m_earth = 5.9720e24          # [kg]  <float> Earth mass M⊕
v_earth = 2.97852e4          # [m/s] <float> Earth orbital velocity (if orbit was circular) V⊕
hour = 60 * 60               # [s] One hour in seconds
day = hour * 24              # [s] One day in seconds
year = day * 365.24219       # [s] Approximately one tropical earth year in seconds
rad2deg = 57.29577951308232  # 180 / pi

[Results]                    # Comment out the first parameter if you do not need the results (transit times etc.) of the simulation.
result_file = TOI-4504_F101.json  # <string> simulation results like transit times are saved in this file
result_dt = 75000            # Real time differences between simulation iterations when calculating transit times.
                             # This parameter is only used after the main simulation for finding the precise values for the transit parameters.
max_interval_extensions = 5  # In unstable systems or when using a very large dt, sometimes the search for an TT has to be extended
                             # If no TT has been found max_interval_extensions * dt around the expected interval between 2 iterations
                             # the search for this particular TT will be aborted. (dt comes from the list dts.)
comment = F101               # You can use this comment for example as diagram title in your result plots
;verbose = True              # If False, only error messages will be printed to the console. Useful when running MCMC. Default: False

[Simulation]                 # Time intervalls and time steps of the simulation
                             # When fitting the simulation to real data, only the parameters start_date and dt are relevant.
;action = results_only        # No simulating, no fitting. Just read some results and generate reports.
results_directory = ../results/mcmc  # All results are saved in the next available numbered subdirectory
;action = single_run          # No fitting. Just a single run of the simulation.
action = mcmc
;action = lmfit
;action = guifit
start_date = 2458400         # [days] <float> Date at the start of the simulation. Often called t0. Typically Barycentric Julian Date (TDB).
dt = 75000                   # [s] <float> real time difference between simulation iterations outside of simulation intervals where data is collected and used
                             # Needs to be small enough in order to calculate with sufficient
                             # precision when objects are close to each other.
                             # Reasonable values can easily be under 10 seconds or over 1e6 seconds.
                             # Set dt to a relatively high value, to improve performance when running MCMC
                             # Set dt to a relatively low value, when you want exact transit times in the result file.
starts = [2458400]           # [days] <float> starting times of the intervalls for which simulation data will be calculated
ends =   [2461000]           # [days] <float>   ending times of the intervalls for which simulation data will be calculated
dts =    [75000]             # [s] <float> real time differences between simulation iterations inside each intervall
                             # When fitting the simulation to measured flux, dt is typically identical with the exposure time of each measurement.
                             # Together, starts, ends and dts define the total number of simulation iterations 'total_iterations' for
                             # which data will be stored. total_iterations is usually much larger than the parameter frames. So not
                             # each simulation iteration will be shown in the video. Instead only 1/sampling_rate of the calculated
                             # iterations is used as a frame in the animation. sampling_rate = (total_iterations - 1) // frames + 1
                             # (// is integer-division)
                             # dt * sampling_rate is the real time difference between 2 frames in the animation.
                             # dt is proportional to the velocity of the objects in the animation.
                             # Because dt can change between intervalls, so can the animated velocity of objects in the video.
;sim_flux_file = ../data/simulations/sim001.csv # <string> When this parameter is provided, the simulated flux will be saved.
                             # The file has the same structure as the files containg measurered flux data which CurveSimulator can process:
                             # It is a CSV file with columns time, flux and flux_err.
sim_flux_err = 0.004         # White noise with standard deviation sim_flux_err will be added to the simulated flux.


[Fitting]                    # This section is only relevant for running a MCMC algorithm to fit the simulation to real data
;mcmc_multi_processing = False  # Much faster but can be useful to switch it off when debugging. Default: True
free_parameters = 13         # Number of free parameters in the fitting model. Relevant for calculating p-value from Chi squared.
;flux_file = ../data/TOI-4504/TOI4504_transits_0.45d_3-97.csv  # <string> file with flux measurements (real data)
;flux_file = ../data/TOI-4504/TOI4504_transits_0.45d_3-97_wo61.csv  # <string> file with flux measurements (real data)
flux_file = ../data/TOI-4504/TOI4504_tt_incl_early_d.csv  # <string> file with flux measurements (real data)
                             # flux_file has 3 columns: time [days], normalized flux, normalized flux standard deviation
                             # While fitting, no result file and no video will be generated.
;guifit = True                # True for interactive fit via GUI. Default: False
;lmfit = True                 # True for LMfit, False for MCMC. Default: False
lmfit_method = powell
;lmfit_method = differential_evolution
;lmfit_method = nelder
flux_weight = 1  # weighting flux residuals against rv and tt residuals
rv_file = ../data/TOI-4504/rv.csv # <string> file with radial velocity measurements (real data)
rv_body = TOI4504
;tt_file = ../data/TOI-4504/tt.csv # <string> file with measured transit times (real data)
;tt_file = ../data/TOI-4504/tt_without_sector_61.csv # <string> file with measured transit times (real data)
tt_weight = 1  # weighting tt residuals against rv and flux residuals
eclipsers_names = TOI4504c, TOI4504d  # only primary transits by these bodies are relevant when fitting for TT
eclipsees_names = TOI4504              # only transits eclipsing these bodies are relevant when fitting for TT
target_flux = 0.985  # Expected normalized flux during transits. Used for a simplified fitting of the transits
                     # times without searching for the precise transit times in the simulated flux

;fitting_results_directory = ../results/mcmc  # All MCMC results are saved in the next available numbered subdirectory
;backend = T058_backend.h5
;load_backend = True
walkers = 32#512              # Number of mcmc chains
burn_in = 1#2500             # Number_of_points_disregarded (burn-in phase). Must be positive. Typically, 1000 is a good value.
thin_samples = 1#50          # Keep only every <thin_samples>th sample from the chain to reduce autocorrelation in the chains and the size of the resulting arrays.
chunk_size = 5#500          # Every chunk_size steps after burn-in phase, results will be saved.
steps = 1e8                # Number of mcmc steps after burn-in phase

moves =  (emcee.moves.StretchMove(a=8.0)     )            # Algorithm emcee uses moves for changing the parameters after each iteration
;moves =  (emcee.moves.StretchMove(a=2.0)     )
;moves =  (emcee.moves.KDEMove()              )
;moves =  (emcee.moves.DEMove     ()     , 0.6), (emcee.moves.DESnookerMove(), 0.2)
;moves =  (emcee.moves.StretchMove()     , 0.6), (emcee.moves.DEMove       (), 0.4)
;moves =  (emcee.moves.DEMove     ()     , 0.8), (emcee.moves.DESnookerMove(), 0.2)
;moves = [(emcee.moves.DEMove     ()     , 0.6), (emcee.moves.DESnookerMove(), 0.2), (emcee.moves.StretchMove(a=2.0), 0.2)]
;moves = [(emcee.moves.DEMove     ()     , 0.5), (emcee.moves.DESnookerMove(), 0.3), (emcee.moves.WalkMove(), 0.2)]
;moves =  (emcee.moves.StretchMove()           ,  emcee.moves.WalkMove()           ,  emcee.moves.DEMove())
# DEMove: 50% langsamer als StretchMove
# DESnookerMove: superschnell, ineffektiv?
# WalkMove: superschnell, ineffektiv?
# StretchMove: Klassiker
# RedBlueMove:
# KDEMove: Use MANY walkers!
# GaussianMove: braucht covarianz als Argument?!?!

bins = 200#, 30              # Number of bins in mcmc histograms. May be several values separated by comma. Then a histogram will be generated for every bin value.
;unit = {"mass": "m_earth", "radius": "r_earth", "e": "1", "i": "deg", "P": "d", "a": "AU", "Omega": "deg", "omega": "deg", "pomega": "deg", "L": "deg", "ma": "deg", "ea": "deg", "nu": "deg", "T": "s", "t": "s"}
unit = {"mass": "m_jup", "radius": "r_jup", "e": "1", "i": "deg", "P": "d", "a": "AU", "Omega": "deg", "omega": "deg", "pomega": "deg", "L": "deg", "ma": "deg", "ea": "deg", "nu": "deg", "T": "s", "t": "s"}
                             # Specify for each of the above body parameters its unit to be used in mcmc result plots
;scale = {"mass": 1/m_earth, "radius": 1/r_earth, "e": 1, "i": rad2deg, "P": 1 /day, "a": 1/au, "Omega": rad2deg, "omega": rad2deg, "pomega": rad2deg, "L": rad2deg, "ma": rad2deg, "ea": rad2deg, "nu": rad2deg, "T": 1, "t": 1}
scale = {"mass": 1/m_jup, "radius": 1/r_jup, "e": 1, "i": rad2deg, "P": 1/day, "a": 1/au, "Omega": rad2deg, "omega": rad2deg, "pomega": rad2deg, "L": rad2deg, "ma": rad2deg, "ea": rad2deg, "nu": rad2deg, "T": 1, "t": 1}
                             # Specify for each of the above body parameters the value it has
                             # to be multiplied with in order to represent its above specified unit.


[Video]                      # This section controls length and quality of the simulation and the resulting video.
                             # Comment out the first parameter to prevent video generation.
;video_file = ../animations/TOI-4504.mp4  # <string> the resulting video is saved in this file
frames = 60                  # <int> number of frames of video. Proportional to Curvesimulator's run time
                             # and to the length of the animation.
fps = 10                     # <int> frames per second in video. Proportional to the velocity of the
                             # objects in the animation. Inverse proportional to length of video.

[Scale]                      # This section controls the size of objects in the animation.
scope_left = 0.4 * au        # [m] <float> scope of left plotting window is [-scope_left, scope_left].
                             # Middle of window is (0.0, 0.0)
scope_right = 0.4 * au       # [m] <float> scope of right plotting window is [-scope_right, scope_right].
                             # Middle of window is (0.0, 0.0)
autoscaling = on             # <string> allowed values: on, off
star_scale_left = 100.0      # [1] <float> (if autoscale off) animate stars with StarScale_left times
                             # enlarged radius in left view.
planet_scale_left = 1000.0   # [1] <float> (if autoscale off) animate planets with PlanetScale_left times
                             # enlarged radius in left view.
star_scale_right = 100.0     # [1] <float> (if autoscale off) animate stars with StarScale_right times
                             # enlarged radius in right view.
planet_scale_right = 1000.0  # [1] <float> (if autoscale off) animate planets with PlanetScale_right times
                             # enlarged radius in right view.
min_radius = 0.4             # [%] <float> (if autoscale on) radius of smallest body in animation relative
                             # to plot scope. radius=100 would fill the whole plot.
max_radius = 2.0             # [%] <float> (if autoscale on) maximum radius of largest body in animation
                             # relative to plot scope. radius=100 would fill the whole plot.
                             # If necessary, scaling will be done logarithmically instead of linear.

[Plot]                       # Adjust the plot parameters in this section only if the plots in the video do not fit your screen
figure_width = 16            # <int>   width of figure which contains all plots and animations
figure_height = 8            # <int>   height of figure which contains all plots and animations
xlim = 1.25                  # <float> left and right view both show x-values between -Xlim and + Xlim
ylim = 1.0                   # <float> left and right view both show y-values between -Ylim and + Ylim
flux_dot_height = 1/17       # <float> height of red dot in light curve plot relative to height of y-axis
flux_dot_width = 1/335       # <float> width of red dot in light curve plot relative to width of x-axis
rv_dot_height = 1/17         # <float> height of red dot in light curve plot relative to height of y-axis
rv_dot_width = 1/335         # <float> width of red dot in light curve plot relative to width of x-axis


[TOI4504]
body_type = star
primary = self
color = 0.99, 0.99, 0.99
#           value               lower bound       upper bound        sigma
mass = 927.12 * m_jup,          #850 * m_jup,      1070 * m_jup,       100 * m_jup
;mass = 0.885 * m_sun,           0.84 * m_sun,     0.94 * m_sun,      0.025 * m_sun
radius = 0.92 * r_sun
luminosity = 0.62 * l_sun
limb_darkening_1 = 0.4765  # paper contains different parameters q1, q2 for different planets. I averaged them. The effective difference is tiny.
limb_darkening_2 = 0.3495
limb_darkening_parameter_type = q


;[TOI4504b]
;body_type = planet
;primary =   TOI-4504
;color =     0.99, 0.01, 0.01
;#           value               lower bound       upper bound        sigma
;mass =      10.4 * m_earth,   # 1.0 * m_earth,    20.0 * m_earth,    10 * m_earth
;radius =    2.691 * r_earth,  # 0.01 * r_earth,   5.0 * r_earth,     2.0 * r_earth
;e =         0                 #
;i =         86.5,             # 84.0,             89.0,              1.5
;P =         2.42614 * day,    # 2.426 * day,      2.4263 * day,      0.00005 * day
;Omega =     0                 #
;omega =     90                #
;ma =        303.6,            # 301.25,           306.25,            1


[TOI4504d]
body_type = planet
primary =   TOI-4504
color =     0.01, 0.99, 0.01
#           value               lower bound       upper bound        sigma
mass =      2.1278 * m_jup,     1.0 * m_jup,      5.0 * m_jup,       0.04 * m_jup
radius =    0.95 * r_jup,       0.2 * r_jup,      2.0 * r_jup,       0.2 * r_jup
e =         0.2498,             0.0,              0.5,               0.005
i =         88.8,               88.5,             89.1,              0.1
P =         41.7878 * day,      41.75 * day,      41.85 * day,       0.015 * day
Omega =     2.5,                0,                6,                 2
omega =     275.80,             100,              460,               4.0
ma =        -20.46,             -200,             160,               8.0


[TOI4504c]
body_type = planet
primary =   TOI-4504
color =     0.99, 0.99, 0.01
#           value               lower bound       upper bound        sigma
mass =      2.6315 * m_jup,     1.0 * m_jup,      5.0 * m_jup,       0.025 * m_jup
radius =    1.07 * r_jup,       0.8 * r_jup,      1.2 * r_jup,       0.03 * r_jup
e =         0.0377,             0.0,              0.5,               0.0035
i =         89.66,              89.4,             90.0,              0.03
P =         81.4631 * day,      81.4 * day,       81.5 * day,        0.03 * day
Omega =     0.8,
omega =     298.89,             200,              400,               6.0
ma =        142.72,             -30,              330,               6.0
